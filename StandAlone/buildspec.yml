version: 0.2

phases:
  install:
    commands:
      # Instala a versão especificada do Terraform em um diretório local e o adiciona ao PATH do ambiente
      - echo "Instalando Terraform v${TERRAFORM_VERSION}..."
      - wget -q https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_arm64.zip
      - unzip -q terraform_${TERRAFORM_VERSION}_linux_arm64.zip
      - mkdir -p bin
      - mv terraform bin/
      - export PATH="$CODEBUILD_SRC_DIR/bin:$PATH"
      - terraform --version
      - echo "Instalação do Terraform concluída."

  pre_build:
    commands:
      # Define variáveis de ambiente para a configuração do backend do Terraform
      - export TF_STATE_BUCKET=${AWS_S3_BUCKET_TARGET_NAME_0}
      - export TF_LOCK_TABLE=${AWS_DYNAMODB_TABLE_TARGET_NAME_0}

      # Muda o diretório de trabalho para onde os arquivos do Terraform ficarão
      - echo "Mudando para o diretório de trabalho: ${CODEBUILD_SRC_DIR}/StandAlone"
      - cd ${CODEBUILD_SRC_DIR}/StandAlone

      # --- Bloco de Processamento de Fontes Secundárias para Replicar Ambiente Local ---
      - echo "Procurando e processando fontes secundárias..."
      - |
        # Verifica se a variável com a lista de identificadores foi passada pela Lambda
        if [ -n "$SECONDARY_SOURCE_IDENTIFIERS" ]; then
          echo "Identificadores de fontes secundárias encontrados: '${SECONDARY_SOURCE_IDENTIFIERS}'"
          # Faz um loop para cada identificador na string (separados por espaço)
          for identifier in $SECONDARY_SOURCE_IDENTIFIERS; do
            # Constrói o caminho para o diretório onde o CodeBuild baixou a fonte secundária
            SOURCE_PATH="${CODEBUILD_SRC_DIR}_$identifier"
            
            # Constrói o diretório de destino que simula o 'git clone' local.
            # O nome da pasta de destino será o próprio nome do identificador/repositório.
            DEST_DIR="./$identifier"

            echo "Processando fonte '${identifier}' de '${SOURCE_PATH}'..."
            
            # Verifica se o diretório da fonte realmente existe antes de tentar copiar
            if [ -d "$SOURCE_PATH" ]; then
              # Cria o diretório de destino (ex: ./LambdaDeploy)
              echo "Criando diretório de destino: '${DEST_DIR}'"
              mkdir -p "${DEST_DIR}"
              
              # Copia o conteúdo da fonte baixada para dentro do diretório de destino recém-criado
              echo "Copiando conteúdo de '${SOURCE_PATH}' para '${DEST_DIR}'..."
              cp -a ${SOURCE_PATH}/. "${DEST_DIR}/"
            else
              echo "AVISO: Diretório da fonte ${SOURCE_PATH} não encontrado. Pulando."
            fi
          done
        else
          echo "Nenhuma fonte secundária para processar."
        fi
      - echo "Processamento de fontes secundárias concluído."
      # --- Fim do Bloco Modificado ---

      # Baixa o arquivo de configuração principal do Terraform do S3 para o diretório de trabalho
      - echo "Baixando configuração principal de s3://${TF_STATE_BUCKET}/states/${STATE_NAME}/main.tf"
      - aws s3 cp "s3://${TF_STATE_BUCKET}/states/${STATE_NAME}/main.tf" .

      # Inicializa o Terraform no diretório de trabalho, agora com todos os arquivos na estrutura correta
      - echo "Inicializando o Terraform..."
      - |
        terraform init -reconfigure -no-color \
          -backend-config="bucket=${TF_STATE_BUCKET}" \
          -backend-config="key=states/${STATE_NAME}/terraform.tfstate" \
          -backend-config="region=${REGION}" \
          -backend-config="dynamodb_table=${TF_LOCK_TABLE}"

  build:
    commands:
      # Executa o comando Terraform (plan, apply, ou destroy) passado pela variável de ambiente COMMAND
      - |
        set -e
        echo "Executando terraform ${COMMAND}..."
        if [ "${COMMAND}" = "plan" ]; then
          terraform plan -no-color
        elif [ "${COMMAND}" = "apply" ]; then
          terraform apply -auto-approve -no-color
        elif [ "${COMMAND}" = "destroy" ]; then
          terraform destroy -auto-approve -no-color
        else
          echo "ERRO: Comando desconhecido '${COMMAND}'. Use 'plan', 'apply' ou 'destroy'."
          exit 1
        fi

  post_build:
    commands:
      - echo "Processo do CodeBuild finalizado."
